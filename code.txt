import React, { useState, useEffect, useMemo } from "react";
import GraphWithProvider from "./HierarchicalGraph"; // Adjust the path as necessary
import {
  controlsStyles,
  controlsLabelStyles,
  controlsInputStyles,
  controlsSpanStyles,
  graphContainerStyles,
} from "./styles";

interface DataItem {
  parent_node: string | null;
  node: string;
  graph_depth: number;
  type: string;
  name: string;
  value: string;
}

const App: React.FC = () => {
  const [sliderValue, setSliderValue] = useState<number>(0);
  const [rawData, setRawData] = useState<DataItem[]>([]);

  useEffect(() => {
    // Fetch data from the REST API
    fetch("https://your-api-endpoint.com/data") // Replace with your actual API endpoint
      .then((response) => response.json())
      .then((data) => {
        // Convert graph_depth to number
        const processedData = data.map((item: any) => ({
          ...item,
          graph_depth: Number(item.graph_depth),
        }));
        setRawData(processedData);
      })
      .catch((error) => {
        console.error("Error fetching data:", error);
      });
  }, []);

  const processedData = useMemo(() => {
    // Process the rawData here if needed
    return rawData;
  }, [rawData]);

  return (
    <div style={{ height: "100vh", overflow: "hidden" }}>
      <div style={controlsStyles}>
        <label style={controlsLabelStyles}>
          Slider Value:
          <input
            type="range"
            min="0"
            max="100"
            value={sliderValue}
            onChange={(e) => setSliderValue(parseInt(e.target.value, 10))}
            style={controlsInputStyles}
          />
          <span style={controlsSpanStyles}>{sliderValue}</span>
        </label>
      </div>
      <div style={graphContainerStyles}>
        <GraphWithProvider data={processedData} sliderValue={sliderValue} />
      </div>
    </div>
  );
};

export default App;




import React, { useState, useEffect } from 'react';
import GraphWithProvider from './GraphWithProvider'; // Adjust the import path as per your project

const App: React.FC = () => {
  const [sliderValue, setSliderValue] = useState<number>(0);
  const [jsonData, setJsonData] = useState<any[]>([]); // State to store JSON data

  useEffect(() => {
    // Function to fetch JSON data
    const fetchData = async () => {
      try {
        const response = await fetch('/data.json'); // Adjust path as per your JSON file location
        if (!response.ok) {
          throw new Error('Failed to fetch JSON data');
        }
        const data = await response.json();
        setJsonData(data); // Set JSON data to state
      } catch (error) {
        console.error('Error fetching JSON data:', error);
      }
    };

    fetchData(); // Call the fetch function when component mounts
  }, []);

  const controlsStyles = {
    marginBottom: '20px',
    padding: '10px',
    backgroundColor: '#f0f0f0',
    boxShadow: '0 0 5px rgba(0, 0, 0, 0.2)',
  };

  const controlsLabelStyles = {
    marginRight: '10px',
    fontSize: '16px',
  };

  const controlsInputStyles = {
    marginRight: '10px',
    marginLeft: '10px',
  };

  const controlsSpanStyles = {
    fontSize: '16px',
    fontWeight: 'bold',
  };

  const graphContainerStyles = {
    padding: '20px',
    border: '1px solid #ccc',
    borderRadius: '5px',
    backgroundColor: '#fff',
  };

  return (
    <div style={{ height: "100vh", overflow: "hidden" }}>
      <div style={controlsStyles}>
        <label style={controlsLabelStyles}>
          Slider Value:
          <input
            type="range"
            min="0"
            max="100"
            value={sliderValue}
            onChange={(e) => setSliderValue(parseInt(e.target.value, 10))}
            style={controlsInputStyles}
          />
          <span style={controlsSpanStyles}>{sliderValue}</span>
        </label>
      </div>
      <div style={graphContainerStyles}>
        {/* Pass jsonData to GraphWithProvider */}
        <GraphWithProvider data={jsonData} />
      </div>
    </div>
  );
};

export default App;








import React, { useState, useEffect } from "react";
import ReactFlow, {
  MiniMap,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  ReactFlowProvider,
  useReactFlow,
  Node,
  Edge,
} from "reactflow";
import "reactflow/dist/style.css";
import dagre from "dagre";
import {
  graphContainerStyles,
  controlsStyles,
  controlsLabelStyles,
  controlsInputStyles,
  controlsSelectStyles,
  controlsSpanStyles,
  reactflowWrapperStyles,
} from "./styles";

interface DataItem {
  parent_node: string | null;
  node: string;
  graph_depth: number;
  type: string;
  name: string;
  value: string;
}

interface HierarchicalGraphProps {
  data: DataItem[];
  sliderValue: number;
}

const nodeWidth = 172;
const nodeHeight = 36;

const dagreGraph = new dagre.graphlib.Graph();
dagreGraph.setDefaultEdgeLabel(() => ({}));

const parseData = (data: DataItem[]) => {
  const hierarchy: { [key: string]: any } = {};

  data.forEach((item) => {
    const { parent_node, node, graph_depth, type, name, value } = item;

    if (!hierarchy[node]) {
      hierarchy[node] = {
        id: node,
        label: name,
        children: [],
        type,
        name,
        value,
        graph_depth,
      };
    }

    if (parent_node) {
      if (!hierarchy[parent_node]) {
        hierarchy[parent_node] = { id: parent_node, children: [] };
      }
      hierarchy[parent_node].children.push(hierarchy[node]);
    }
  });

  return hierarchy;
};

const getNodeColor = (type: string) => {
  switch (type) {
    case "input":
      return "#FFD700"; // Gold
    case "output":
      return "#FF6347"; // Tomato
    case "option":
      return "#40E0D0"; // Turquoise
    default:
      return "#D3D3D3"; // Light Gray
  }
};

const getLayoutedElements = (
  nodes: Node[],
  edges: Edge[],
  direction: string = "TB"
) => {
  const isHorizontal = direction === "LR" || direction === "RL";
  dagreGraph.setGraph({ rankdir: direction });

  nodes.forEach((node) => {
    dagreGraph.setNode(node.id, { width: nodeWidth, height: nodeHeight });
  });

  edges.forEach((edge) => {
    dagreGraph.setEdge(edge.source, edge.target);
  });

  dagre.layout(dagreGraph);

  nodes.forEach((node) => {
    const nodeWithPosition = dagreGraph.node(node.id);
    (node as any).targetPosition = isHorizontal ? "left" : "top";
    (node as any).sourcePosition = isHorizontal ? "right" : "bottom";

    node.position = {
      x: nodeWithPosition.x - nodeWidth / 2,
      y: nodeWithPosition.y - nodeHeight / 2,
    };

    return node;
  });

  return { nodes, edges };
};

const HierarchicalGraph: React.FC<HierarchicalGraphProps> = ({
  data,
  sliderValue,
}) => {
  const hierarchy = parseData(data);
  const [selectedParentNode, setSelectedParentNode] =
    useState("<SCLRootCalcNode>");
  const initialElements: Node[] = [
    {
      id: hierarchy[selectedParentNode].id,
      type: hierarchy[selectedParentNode].type,
      data: { label: hierarchy[selectedParentNode].label },
      position: { x: 0, y: 0 },
      style: {
        backgroundColor: getNodeColor(hierarchy[selectedParentNode].type),
      },
    },
  ];

  const [nodes, setNodes, onNodesChange] = useNodesState(initialElements);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [expandedNodes, setExpandedNodes] = useState<string[]>([]);
  const [direction, setDirection] = useState("TB");

  const { project } = useReactFlow();

  const expandNode = (node: Node) => {
    if (
      !hierarchy[node.id] ||
      !hierarchy[node.id].children ||
      hierarchy[node.id].children.length === 0
    ) {
      return;
    }

    const currentExpandedNodes = new Set(expandedNodes);

    if (currentExpandedNodes.has(node.id)) {
      // Collapse the node
      currentExpandedNodes.delete(node.id);
      // Remove children nodes and their edges
      const nodesToKeep = nodes.filter(
        (n) =>
          !hierarchy[node.id].children.some((child: any) => child.id === n.id)
      );
      const edgesToKeep = edges.filter(
        (e) =>
          !hierarchy[node.id].children.some(
            (child: any) => e.source === node.id && e.target === child.id
          )
      );
      setNodes(nodesToKeep);
      setEdges(edgesToKeep);
    } else {
      // Expand the node
      currentExpandedNodes.add(node.id);

      const newNodes = [...nodes];
      const newEdges = [...edges];

      hierarchy[node.id].children.forEach((child: any) => {
        const position = project({
          x: node.position.x + (Math.random() - 0.5) * 200,
          y: node.position.y + 100,
        });
        newNodes.push({
          id: child.id,
          data: { label: child.label },
          position,
          style: { backgroundColor: getNodeColor(child.type) },
        });

        newEdges.push({
          id: `${node.id}-${child.id}`,
          source: node.id,
          target: child.id,
          type: "smoothstep",
          animated: false,
        });

        // Recursively expand child nodes if they are already in the expanded list
        if (currentExpandedNodes.has(child.id)) {
          expandNode(child);
        }
      });

      setNodes(newNodes);
      setEdges(newEdges);
    }

    setExpandedNodes(Array.from(currentExpandedNodes));
  };

  useEffect(() => {
    const layoutedElements = getLayoutedElements(nodes, edges, direction);
    setNodes(layoutedElements.nodes);
    setEdges(layoutedElements.edges);
  }, [nodes.length, edges.length, sliderValue, direction]);

  useEffect(() => {
    const selectedNode = hierarchy[selectedParentNode];
    if (selectedNode) {
      const initialElements = [
        {
          id: selectedNode.id,
          type: selectedNode.type,
          data: { label: selectedNode.label },
          position: { x: 0, y: 0 },
          style: { backgroundColor: getNodeColor(selectedNode.type) },
        },
      ];
      setNodes(initialElements);
      setEdges([]);
      setExpandedNodes([]);
    }
  }, [selectedParentNode]);

  return (
    <div style={graphContainerStyles}>
      <div style={controlsStyles}>
        <label style={controlsLabelStyles}>
          Direction:
          <select
            value={direction}
            onChange={(e) => setDirection(e.target.value)}
            style={controlsSelectStyles}
          >
            <option value="TB">Top-Bottom</option>
            <option value="BT">Bottom-Top</option>
            <option value="LR">Left-Right</option>
            <option value="RL">Right-Left</option>
          </select>
        </label>
        <label style={{ ...controlsLabelStyles, marginLeft: "20px" }}>
          Parent Node:
          <select
            value={selectedParentNode}
            onChange={(e) => setSelectedParentNode(e.target.value)}
            style={controlsSelectStyles}
          >
            {Object.keys(hierarchy).map((key) => (
              <option key={key} value={key}>
                {hierarchy[key].label}
              </option>
            ))}
          </select>
        </label>
      </div>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        fitView
        onNodeClick={(event, node) => expandNode(node)}
      >
        <MiniMap />
        <Controls />
        <Background />
      </ReactFlow>
    </div>
  );
};

const GraphWithProvider: React.FC<HierarchicalGraphProps> = (props) => (
  <ReactFlowProvider>
    <HierarchicalGraph {...props} />
  </ReactFlowProvider>
);

export default GraphWithProvider;
// /component/Hierarchical.tsx



// src/styles.ts

import { CSSProperties } from 'react';

export const globalStyles: CSSProperties = {
  margin: 0,
  padding: 0,
  boxSizing: 'border-box',
};

export const bodyHtmlStyles: CSSProperties = {
  width: '100%',
  height: '100%',
  overflow: 'hidden',
};

export const graphContainerStyles: CSSProperties = {
  height: '100vh',
  width: '100vw',
  display: 'flex',
  flexDirection: 'column',
  overflow: 'hidden',
};

export const controlsStyles: CSSProperties = {
  padding: '10px',
  display: 'flex',
  justifyContent: 'space-around',
  alignItems: 'center',
  backgroundColor: '#f7f7f7',
  borderBottom: '1px solid #dddddd',
};

export const controlsLabelStyles: CSSProperties = {
  fontSize: '14px',
  color: '#333',
  marginRight: '20px',
  display: 'flex',
  alignItems: 'center',
};

export const controlsInputStyles: CSSProperties = {
  marginLeft: '10px',
  width: '150px',
};

export const controlsSelectStyles: CSSProperties = {
  marginLeft: '10px',
  padding: '4px',
  fontSize: '14px',
};

export const controlsSpanStyles: CSSProperties = {
  marginLeft: '10px',
  fontSize: '14px',
  color: '#666',
};

export const reactflowWrapperStyles: CSSProperties = {
  flex: 1,
  position: 'relative',
};

export const navbarStyles: CSSProperties = {
  backgroundColor: '#3498db',
  color: 'white',
  padding: '10px',
  display: 'flex',
  justifyContent: 'space-between',
  alignItems: 'center',
};

export const rootStyles: CSSProperties = {
  margin: 0,
  padding: 0,
  width: '100%',
  height: '100%',
};

export const nodeStyles: CSSProperties = {
  padding: '10px',
  backgroundColor: 'black',
  border: '1px solid #dddddd',
  borderRadius: '5px',
  width: '250px',
  height: '70px',
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  fontSize: '14px',
};

// /component/styles.ts


import React, { useState, useMemo } from "react";
import { FixedSizeList as List } from "react-window";
import GraphWithProvider from "./components/HierarchicalGraph";

const rawData = [
  {
    parent_node: null,
    node: "<SCLRootCalcNode>",
    graph_depth: 0,
    type: "input",
    name: "Root",
    value: "",
  },
  {
    parent_node: "<SCLRootCalcNode>",
    node: "Child 1 of Root",
    graph_depth: 1,
    type: "output",
    name: "Child 1",
    value: "Data 1",
  },
  {
    parent_node: "<SCLRootCalcNode>",
    node: "Child 2 of Root",
    graph_depth: 1,
    type: "output",
    name: "Child 2",
    value: "Data 2",
  },
  {
    parent_node: "<SCLRootCalcNode>",
    node: "Child 3 of Root",
    graph_depth: 1,
    type: "output",
    name: "Child 3",
    value: "Data 3",
  },
  {
    parent_node: "<SCLRootCalcNode>",
    node: "Child 4 of Root",
    graph_depth: 1,
    type: "output",
    name: "Child 4",
    value: "Data 4",
  },
  {
    parent_node: "<SCLRootCalcNode>",
    node: "Child 5 of Root",
    graph_depth: 1,
    type: "output",
    name: "Child 5",
    value: "Data 5",
  },
  {
    parent_node: "<SCLRootCalcNode>",
    node: "Child 6 of Root",
    graph_depth: 1,
    type: "output",
    name: "Child 6",
    value: "Data 6",
  },
  {
    parent_node: "<SCLRootCalcNode>",
    node: "Child 7 of Root",
    graph_depth: 1,
    type: "output",
    name: "Child 7",
    value: "Data 7",
  },
  {
    parent_node: "<SCLRootCalcNode>",
    node: "Child 8 of Root",
    graph_depth: 1,
    type: "output",
    name: "Child 8",
    value: "Data 8",
  },
  {
    parent_node: "<SCLRootCalcNode>",
    node: "Child 9 of Root",
    graph_depth: 1,
    type: "output",
    name: "Child 9",
    value: "Data 9",
  },
  {
    parent_node: "<SCLRootCalcNode>",
    node: "Child 10 of Root",
    graph_depth: 1,
    type: "output",
    name: "Child 10",
    value: "Data 10",
  },
  {
    parent_node: "Child 1 of Root",
    node: "Grandchild 1.1",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 1.1",
    value: "Data 1.1",
  },
  {
    parent_node: "Child 1 of Root",
    node: "Grandchild 1.2",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 1.2",
    value: "Data 1.2",
  },
  {
    parent_node: "Child 1 of Root",
    node: "Grandchild 1.3",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 1.3",
    value: "Data 1.3",
  },
  {
    parent_node: "Child 1 of Root",
    node: "Grandchild 1.4",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 1.4",
    value: "Data 1.4",
  },
  {
    parent_node: "Child 1 of Root",
    node: "Grandchild 1.5",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 1.5",
    value: "Data 1.5",
  },
  {
    parent_node: "Child 2 of Root",
    node: "Grandchild 2.1",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 2.1",
    value: "Data 2.1",
  },
  {
    parent_node: "Child 2 of Root",
    node: "Grandchild 2.2",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 2.2",
    value: "Data 2.2",
  },
  {
    parent_node: "Child 2 of Root",
    node: "Grandchild 2.3",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 2.3",
    value: "Data 2.3",
  },
  {
    parent_node: "Child 2 of Root",
    node: "Grandchild 2.4",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 2.4",
    value: "Data 2.4",
  },
  {
    parent_node: "Child 2 of Root",
    node: "Grandchild 2.5",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 2.5",
    value: "Data 2.5",
  },
  {
    parent_node: "Child 3 of Root",
    node: "Grandchild 3.1",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 3.1",
    value: "Data 3.1",
  },
  {
    parent_node: "Child 3 of Root",
    node: "Grandchild 3.2",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 3.2",
    value: "Data 3.2",
  },
  {
    parent_node: "Child 3 of Root",
    node: "Grandchild 3.3",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 3.3",
    value: "Data 3.3",
  },
  {
    parent_node: "Child 3 of Root",
    node: "Grandchild 3.4",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 3.4",
    value: "Data 3.4",
  },
  {
    parent_node: "Child 3 of Root",
    node: "Grandchild 3.5",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 3.5",
    value: "Data 3.5",
  },
  {
    parent_node: "Child 4 of Root",
    node: "Grandchild 4.1",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 4.1",
    value: "Data 4.1",
  },
  {
    parent_node: "Child 4 of Root",
    node: "Grandchild 4.2",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 4.2",
    value: "Data 4.2",
  },
  {
    parent_node: "Child 4 of Root",
    node: "Grandchild 4.3",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 4.3",
    value: "Data 4.3",
  },
  {
    parent_node: "Child 4 of Root",
    node: "Grandchild 4.4",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 4.4",
    value: "Data 4.4",
  },
  {
    parent_node: "Child 4 of Root",
    node: "Grandchild 4.5",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 4.5",
    value: "Data 4.5",
  },
  {
    parent_node: "Child 5 of Root",
    node: "Grandchild 5.1",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 5.1",
    value: "Data 5.1",
  },
  {
    parent_node: "Child 5 of Root",
    node: "Grandchild 5.2",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 5.2",
    value: "Data 5.2",
  },
  {
    parent_node: "Child 5 of Root",
    node: "Grandchild 5.3",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 5.3",
    value: "Data 5.3",
  },
  {
    parent_node: "Child 5 of Root",
    node: "Grandchild 5.4",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 5.4",
    value: "Data 5.4",
  },
  {
    parent_node: "Child 5 of Root",
    node: "Grandchild 5.5",
    graph_depth: 2,
    type: "option",
    name: "Grandchild 5.5",
    value: "Data 5.5",
  },
];

const controlsStyles = {
  marginBottom: "20px",
};

const controlsLabelStyles = {
  marginRight: "10px",
};

const controlsInputStyles = {
  marginRight: "10px",
};

const controlsSpanStyles = {
  fontWeight: "bold",
};

const graphContainerStyles = {
  height: "calc(100vh - 50px)", // Adjust the height based on your controls' height
  overflow: "hidden",
};

const App: React.FC = () => {
  const [sliderValue, setSliderValue] = useState<number>(0);

  // Use useMemo to memoize the processed data
  const processedData = useMemo(() => {
    // Process the rawData here if needed
    return rawData;
  }, [rawData]);

  return (
    <div style={{ height: "100vh", overflow: "hidden" }}>
      <div style={controlsStyles}>
        <label style={controlsLabelStyles}>
          Slider Value:
          <input
            type="range"
            min="0"
            max="100"
            value={sliderValue}
            onChange={(e) => setSliderValue(parseInt(e.target.value, 10))}
            style={controlsInputStyles}
          />
          <span style={controlsSpanStyles}>{sliderValue}</span>
        </label>
      </div>
      <div style={graphContainerStyles}>
        <GraphWithProvider data={processedData} sliderValue={sliderValue} />
      </div>
    </div>
  );
};

export default App;
//app.tsx


import React from "react";
import ReactDOM from "react-dom";
import App from "./App.tsx";

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById("root")
);
//main.tsx


import csv
import json
import os

import csv
import json

# Define the path to your CSV file and the output JSON file
csv_file_path = 'data.csv'
json_file_path = 'data.json'

# Read the CSV file and convert to JSON
csv_data = []
with open(csv_file_path, mode='r', encoding='utf-8') as csv_file:
    csv_reader = csv.reader(csv_file)
    headers = next(csv_reader)  # Read the header row
    headers = headers[1:]  # Remove the first column header
    for row in csv_reader:
        # Remove the first column from each row
        row_data = row[1:]
        # Convert the row to a dictionary
        row_dict = dict(zip(headers, row_data))
        csv_data.append(row_dict)

# Write the JSON data to a file
with open(json_file_path, mode='w', encoding='utf-8') as json_file:
    json.dump(csv_data, json_file, indent=2)

print(f'CSV file has been successfully converted to JSON and saved as {json_file_path}')

