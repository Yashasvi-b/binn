// In App.tsx or wherever you fetch data
import React, { useState, useEffect } from "react";
import ReactDOM from "react-dom";
import axios from "axios";
import GraphWithProvider from "./components/HierarchicalGraph";

const apiUrl = "http://localhost:8100/api/data"; // Replace with your actual API endpoint

const App: React.FC = () => {
  const [sliderValue, setSliderValue] = useState<number>(0);
  const [data, setData] = useState<DataItem[]>([]);

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      const response = await axios.get(apiUrl);
      // Assuming response.data looks like: { "1": [ {...}, {...}, ... ] }
      const dataArray = Object.values(response.data)[0]; // Extract array from "1" key
      setData(dataArray);
    } catch (error) {
      console.error("Error fetching data:", error);
    }
  };

  return (
    <div style={{ height: "100vh", overflow: "hidden" }}>
      <div style={controlsStyles}>
        <label style={controlsLabelStyles}>
          Slider Value:
          <input
            type="range"
            min="0"
            max="100"
            value={sliderValue}
            onChange={(e) => setSliderValue(parseInt(e.target.value, 10))}
            style={controlsInputStyles}
          />
          <span style={controlsSpanStyles}>{sliderValue}</span>
        </label>
      </div>
      <div style={graphContainerStyles}>
        <GraphWithProvider data={data} sliderValue={sliderValue} />
      </div>
    </div>
  );
};

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById("root")
);


-------------------------------------------------------------------------------------------------------







import React, { useState, useEffect } from "react";
import ReactFlow, {
  MiniMap,
  Controls,
  Background,
  useNodes,
  useEdges,
  ReactFlowProvider,
  Node,
  Edge,
} from "reactflow";
import "reactflow/dist/style.css";
import dagre from "dagre";
import {
  graphContainerStyles,
  controlsStyles,
  controlsLabelStyles,
  controlsSelectStyles,
  controlsSpanStyles,
} from "./styles";

interface DataItem {
  parent_node: string | null;
  node: string;
  graph_depth: string; // Adjusted to string because API returns it as string
  type: string;
  name: string;
  value: string;
}

interface HierarchicalGraphProps {
  data: DataItem[];
  sliderValue: number;
}

const nodeWidth = 172;
const nodeHeight = 36;

const dagreGraph = new dagre.graphlib.Graph();
dagreGraph.setDefaultEdgeLabel(() => ({}));

const parseData = (data: DataItem[]) => {
  const hierarchy: { [key: string]: any } = {};

  data.forEach((item) => {
    const { parent_node, node, graph_depth, type, name, value } = item;

    if (!hierarchy[node]) {
      hierarchy[node] = {
        id: node,
        label: name,
        children: [],
        type,
        name,
        value,
        graph_depth: parseInt(graph_depth, 10), // Convert to number if needed
      };
    }

    if (parent_node) {
      if (!hierarchy[parent_node]) {
        hierarchy[parent_node] = { id: parent_node, children: [] };
      }
      hierarchy[parent_node].children.push(hierarchy[node]);
    }
  });

  return hierarchy;
};

const getNodeColor = (type: string) => {
  switch (type) {
    case "input":
      return "#FFD700"; // Gold
    case "output":
      return "#FF6347"; // Tomato
    case "option":
      return "#40E0D0"; // Turquoise
    default:
      return "#D3D3D3"; // Light Gray
  }
};

const getLayoutedElements = (
  nodes: Node[],
  edges: Edge[],
  direction: string = "TB"
) => {
  const isHorizontal = direction === "LR" || direction === "RL";
  dagreGraph.setGraph({ rankdir: direction });

  nodes.forEach((node) => {
    dagreGraph.setNode(node.id, { width: nodeWidth, height: nodeHeight });
  });

  edges.forEach((edge) => {
    dagreGraph.setEdge(edge.source, edge.target);
  });

  dagre.layout(dagreGraph);

  nodes.forEach((node) => {
    const nodeWithPosition = dagreGraph.node(node.id);
    (node as any).targetPosition = isHorizontal ? "left" : "top";
    (node as any).sourcePosition = isHorizontal ? "right" : "bottom";

    node.position = {
      x: nodeWithPosition.x - nodeWidth / 2,
      y: nodeWithPosition.y - nodeHeight / 2,
    };

    return node;
  });

  return { nodes, edges };
};

const HierarchicalGraph: React.FC<HierarchicalGraphProps> = ({
  data,
  sliderValue,
}) => {
  const hierarchy = parseData(data);
  const [selectedParentNode, setSelectedParentNode] = useState("<SCLRootCalcNode>");
  const initialElements: Node[] = [
    {
      id: hierarchy[selectedParentNode].id,
      type: hierarchy[selectedParentNode].type,
      data: { label: hierarchy[selectedParentNode].label },
      position: { x: 0, y: 0 },
      style: {
        backgroundColor: getNodeColor(hierarchy[selectedParentNode].type),
      },
    },
  ];

  const [nodes, setNodes] = useNodes();
  const [edges, setEdges] = useEdges();
  const [expandedNodes, setExpandedNodes] = useState<string[]>([]);
  const [direction, setDirection] = useState("TB");

  const expandNode = (node: Node) => {
    if (
      !hierarchy[node.id] ||
      !hierarchy[node.id].children ||
      hierarchy[node.id].children.length === 0
    ) {
      return;
    }

    const currentExpandedNodes = new Set(expandedNodes);

    if (currentExpandedNodes.has(node.id)) {
      // Collapse the node
      currentExpandedNodes.delete(node.id);
      // Remove children nodes and their edges
      const nodesToKeep = nodes.filter(
        (n) =>
          !hierarchy[node.id].children.some((child: any) => child.id === n.id)
      );
      const edgesToKeep = edges.filter(
        (e) =>
          !hierarchy[node.id].children.some(
            (child: any) => e.source === node.id && e.target === child.id
          )
      );
      setNodes(nodesToKeep);
      setEdges(edgesToKeep);
    } else {
      // Expand the node
      currentExpandedNodes.add(node.id);

      const newNodes = [...nodes];
      const newEdges = [...edges];

      hierarchy[node.id].children.forEach((child: any) => {
        newNodes.push({
          id: child.id,
          data: { label: child.label },
          position: {
            x: node.position.x + (Math.random() - 0.5) * 200,
            y: node.position.y + 100,
          },
          style: { backgroundColor: getNodeColor(child.type) },
        });

        newEdges.push({
          id: `${node.id}-${child.id}`,
          source: node.id,
          target: child.id,
          type: "smoothstep",
          animated: false,
        });

        // Recursively expand child nodes if they are already in the expanded list
        if (currentExpandedNodes.has(child.id)) {
          expandNode(child);
        }
      });

      setNodes(newNodes);
      setEdges(newEdges);
    }

    setExpandedNodes(Array.from(currentExpandedNodes));
  };

  useEffect(() => {
    const layoutedElements = getLayoutedElements(nodes, edges, direction);
    setNodes(layoutedElements.nodes);
    setEdges(layoutedElements.edges);
  }, [nodes.length, edges.length, sliderValue, direction]);

  useEffect(() => {
    const selectedNode = hierarchy[selectedParentNode];
    if (selectedNode) {
      const initialElements = [
        {
          id: selectedNode.id,
          type: selectedNode.type,
          data: { label: selectedNode.label },
          position: { x: 0, y: 0 },
          style: { backgroundColor: getNodeColor(selectedNode.type) },
        },
      ];
      setNodes(initialElements);
      setEdges([]);
      setExpandedNodes([]);
    }
  }, [selectedParentNode]);

  return (
    <ReactFlowProvider>
      <div style={graphContainerStyles}>
        <ReactFlow
          elements={nodes.concat(edges)}
          nodeTypes={{
            input: () => null,
            output: () => null,
            option: () => null,
            default: () => null,
          }}
          edgeTypes={{ smoothstep: () => null }}
          onElementClick={(event, element) => {
            if (element && "id" in element) {
              expandNode(element);
            }
          }}
        >
          <MiniMap />
          <Controls />
          <Background />
        </ReactFlow>
      </div>
    </ReactFlowProvider>
  );
};

export default HierarchicalGraph;
